from flask import Flask, request, jsonify, abort
import logging
import os
import google.generativeai as genai
from github import Github
from datetime import datetime, timezone
import requests
import time

# --- Configure logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')

# --- Get secrets from environment variables ---
MY_SECRET = os.environ.get('MY_APP_SECRET')
# Set the Gemini API key from the secret you just added
genai.configure(
    api_key=os.environ.get("GEMINI_API_KEY"),
    transport='rest' # <-- Add this line
)
GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN')

app = Flask(__name__)

def generate_code_with_llm(brief, attachments):
    """Generates a single HTML file using the Gemini API."""

    prompt = f"""
    Based on the following brief, generate a single, complete HTML file (`index.html`).
    The HTML file must include all necessary CSS and JavaScript in <style> and <script> tags.
    Do not use any external files. The entire web application must be contained in this one file.

    Brief: "{brief}"

    Attachments: {attachments}

    Generate only the HTML code, starting with <!DOCTYPE html> and nothing else.
    """

    try:
        logging.info("Sending request to Google Gemini API...")
        model = genai.GenerativeModel("models/gemini-2.5-flash")
        response = model.generate_content(prompt)
        generated_code = response.text
        logging.info("Successfully received code from Google Gemini API.")
        return generated_code
    except Exception as e:
        logging.error(f"Error calling Google Gemini API: {e}")
        return None

def deploy_to_github(repo_name, html_content, brief):
    """Creates a GitHub repo, pushes content, and returns the repo URLs."""
    try:
        logging.info(f"Connecting to GitHub...")
        g = Github(GITHUB_TOKEN)
        user = g.get_user()
        user_name = user.name if user.name else user.login

        logging.info(f"Creating new repository named: {repo_name}")
        repo = user.create_repo(repo_name, private=False, auto_init=False)

        # --- 1. Create index.html (as before) ---
        logging.info("Pushing index.html...")
        repo.create_file("index.html", "feat: Add generated HTML", html_content, branch="main")

        # --- 2. Create README.md ---
        readme_content = f"""
# {repo_name}

## Summary
This web application was auto-generated by an LLM based on the following brief:
> {brief}

## License
This project is licensed under the MIT License.
"""
        logging.info("Pushing README.md...")
        repo.create_file("README.md", "docs: Add README", readme_content.strip(), branch="main")

        # --- 3. Create LICENSE file ---
        mit_license_text = f"""
MIT License

Copyright (c) 2025 {user_name}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
        logging.info("Pushing LICENSE...")
        # Remember to change "[Your Name or Username]" in the license text!
        repo.create_file("LICENSE", "docs: Add MIT License", mit_license_text.strip(), branch="main")

        repo_url = repo.html_url
        pages_url = f"https://{user.login}.github.io/{repo_name}/"
        commit_sha = repo.get_branch("main").commit.sha
        
        logging.info(f"Successfully created repo: {repo_url}")
        
        return repo_url, pages_url, commit_sha
    except Exception as e:
        logging.error(f"Error during GitHub deployment: {e}")
        return None, None, None
    
def notify_evaluation_server(url, payload):
    """Sends the final results to the evaluation server with retries."""
    retries = 5
    delay = 1  # Start with a 1-second delay
    for i in range(retries):
        try:
            logging.info(f"Attempting to send notification to {url}...")
            response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'}, timeout=10)
            if response.status_code == 200:
                logging.info("Successfully notified evaluation server.")
                return True
            else:
                logging.warning(f"Notification failed with status {response.status_code}. Retrying in {delay}s...")
        except requests.exceptions.RequestException as e:
            logging.error(f"An error occurred while sending notification: {e}. Retrying in {delay}s...")
        
        time.sleep(delay)
        delay *= 2 # Exponential backoff (1s, 2s, 4s, ...)
    
    logging.error("Failed to notify evaluation server after all retries.")
    return False
    
@app.route('/', methods=['POST'])
def handle_request():
    """Handles the incoming project request."""
    request_data = request.get_json()
    # ... (secret verification code remains the same) ...
    if not MY_SECRET or request_data.get('secret') != MY_SECRET:
        logging.error("Secret verification failed.")
        abort(403, "Forbidden: Invalid secret")

    logging.info("Secret verified successfully.")
    
    brief = request_data.get('brief')
    attachments = request_data.get('attachments', [])
    
    if not brief:
        abort(400, "Bad Request: No brief provided.")
    
    # --- 1. Generate Code using LLM ---
    generated_html = generate_code_with_llm(brief, attachments)
    
    if not generated_html:
        abort(500, "Internal Server Error: Failed to generate code.")
        
    # For now, just log the generated code to confirm it works
    logging.info("--- Generated HTML Code ---")
    logging.info(generated_html[:500] + "...") # Log the first 500 chars
    logging.info("--------------------------")
    
    # --- 2. Deploy to GitHub ---
    # Use the 'task' field from the request for a unique repo name
    task_id = request_data.get('task', 'llm-generated-app')
    round_num = request_data.get('round', 1)
    # Generate a unique string from the current time
    timestamp = datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S') 
    # Create a more unique repository name
    repo_name = f"{task_id}-{round_num}-{timestamp}"

    repo_url, pages_url, commit_sha = deploy_to_github(repo_name, generated_html, brief)

    if not repo_url:
        abort(500, "Internal Server Error: Failed to deploy to GitHub.")

    # --- TODO: Final step is to POST these details to the evaluation_url ---
    logging.info(f"Final details: repo_url={repo_url}, pages_url={pages_url}, commit_sha={commit_sha}")

    # --- 3. Notify the Evaluation Server ---
    evaluation_url = request_data.get('evaluation_url')
    if not evaluation_url:
        logging.error("No evaluation_url found in the request.")
        abort(400, "Bad Request: evaluation_url is missing.")

    # Construct the final payload as specified
    final_payload = {
        "email": request_data.get('email'),
        "task": request_data.get('task'),
        "round": request_data.get('round'),
        "nonce": request_data.get('nonce'),
        "repo_url": repo_url,
        "commit_sha": commit_sha,
        "pages_url": pages_url
    }
    
    notify_evaluation_server(evaluation_url, final_payload)

    return jsonify({
        "status": "ok", 
        "message": "Process complete. Evaluation server notified."
    }), 200